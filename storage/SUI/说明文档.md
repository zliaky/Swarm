# Unity界面说明
Robot设有4种状态，GUI输入可改变其状态来执行不同状态下代码。主流程由RoboState.cs与RoboMoniter.cs完成，详细见脚本说明。

在不需要GUI输入，直接用流程控制时，可禁用RoboMoniter，新建脚本代替它控制各RoboState及发送消息。

## GameObject说明
两个主要GameObject为Moniter与Robot（复制5份）。

- Moniter
空物体。
负责判断GUI输入，将GUI输入分配到对应Robot，且负责与串口通信。
挂有以下脚本：
  - RoboMoniter.cs
  - SerialListener.cs

- Robot(x5)
2D Sprite，带有一个文本框子物体。
每个对应一个小机器人，所挂脚本负责自己所对应的那个小机器人的状态变化。
挂有以下脚本：
  - RoboState.cs
  
- Robot(Clone)
当拖拽GUI上的圆圈时创建（灰色那个），方便用户定位目标地点，在robot移动到目的地后销毁。
  
## C#脚本说明
- Serial.cs
  封装dll导入的通讯函数，并构建一接收位置数据的结构体，不做其它任何操作。封装函数如下：
  - `bool initSerial(char[] com)`
  - `void sendMsg(short id, float x, float y, float v)`
  - `void getFrame()` 更新framedata至public结构体。
  - `int closeSerial()`
  
- SerialLisener.cs
  完成串口通讯
  - `void Start()` 实例化Serial打开串口通讯，开启新线程接收数据。
  - `void Update()` 若收到消息，在对应Robot不被GUI操作时，将位置信息更新到对应Robot的RoboState。 监听RoboMoniter的发送请求flag，若请求发送，发送RoboMoniter请求的消息。
  - `void SendData()` 新线程中发送数据
  - `void DataRecv()` 新线程中接收数据
  - `void OnApplicationQuit()` 退出时关闭所有线程并关闭串口通讯。
  
- RoboState.cs
  每个RoboState负责自己所对应的小机器人状态，设有5个state：
    - 0 == 初始化状态，在最开始的原点，闲置。（白）
    - 1 == 闲置 （白）
    - 2 == 被GUI鼠标拖拽中 （红）
    - 3 == 小机器人被人握住，还没用到
    - 4 == 向目的地移动中 （绿）

  - `void Update()` 
  若状态为2，则让自己的克隆体图标跟随鼠标移动，同时将坐标值更新到克隆体的文本框。
  若状态为4，则向目标点移动。
  - `private void gotoDestination()`
  在状态4被调用，现在直接通过计算更新画面上的位移。
  这里需要改为通过串口数据更新GUI位置。
  - `private void moveWithPointer()`
  在状态2被调用，通过鼠标位置更新画面图标位置。
  - `public void setState(int state_idx)` 改变状态值
  - `public int getState()` 获得当前状态值。

- RoboMoniter.cs
  监听GUI输入，设置Robot状态。
  - `void Start()`
  - `void Update()`
  若鼠标按下时选中一个Robot，创建该Robot的copy并更新RoboState为2。
  若鼠标放开，更新RoboState为4，并将鼠标放开时坐标更新到public的坐标，将请求发送的flag设为为true。
  - `void gettheClone(GameObject the_robot)` 创建克隆体，保留外形与子物体，禁用碰撞及RoboState脚本。
  
